syntax = "proto2";

package rhl;

/**
 * 2 Referential are considered, self and field, but only SI units are used
 * - Field:
 *   - Center is 0,0
 *   - X-axis goes from center to opposite goal
 *   - Y-axis goes from center toward left side of the field while facing opposite goal
 * - Self:
 *   - Center is the robot position
 *   - X-axis goes in front of the robot
 *   - Y-axis goes to the left of the robot
 */

/**
 * Estimation of the position of an object with uncertainty
 */
message PositionEstimation {
  /**
   * Position x [m]
   */
  required float x = 1;
  /**
   * Position y [m]
   */
  required float y = 2;

  /**
   * - If empty: not informed
   * - If size 2: ( std_dev_x , std_dev_y )
   * - If size 3: ( covar_x , covar_xy, covar_y)
   */
  repeated float uncertainty = 3;
}

/**
 * Estimation of the pose of an object (position + orientation)
 */
message PoseEstimation {
  /**
   * Position x [m]
   */
  required float x = 1;
  /**
   * Position y [m]
   */
  required float y = 2;
  /**
   * Direction of the object [rad]
   */
  optional float dir = 3;

  /**
   * Note: Use of std_dev and covar for direction are not satisfying here (see Von Mises)
   * - If empty: not informed
   * - If size 3: ( std_dev_x , std_dev_y, std_dev_dir )
   * - If size 6: ( covar_x , covar_xy, covar_xdir, covar_y, covar_ydir, covar_dir)
   */
  repeated float uncertainty = 4;
}

enum TeamID {
  UNKNOWN = 0;
  ALLY = 1;
  OPPONENT = 2;
}

message RobotEstimation {
  /**
   * Team identifier
   */
  required TeamID teamId = 1;

  /**
   * Identifier of the robot:
   * - 0: unknown id
   * - 1+: Identifier of the robot
   */
  required uint32 robotId = 2;
  
  /**
   * Pose of the robots in self referential
   */
  required PoseEstimation robotInSelf = 3;
  
}

/**
 * Perception of the world state by the robot
 */
message PerceptionMessage {
  required PositionEstimation ballInSelf = 1;


  /**
   * Estimation of the pose of the robot in the field referential allowing
   * multiple candidates.
   * - First element represents the probability of the pose
   * - Second element describes the pose
   */
  message WeightedPose {
    required float probability = 1;
    required PoseEstimation pose = 2;
  }
  /**
   * All the pose 
   */
  repeated WeightedPose selfInField = 2;

  /**
   * Position of the opponent goal in self basis.
   *
   * Note: might be inconsistent with 'selfInField'
   */
  optional PositionEstimation oppGoalInSelf = 3;


  /**
   * Wheighted Robot pose.
   * - First element represents the probability that the information is accurate
   * - Second element describes the robot with its Estimation pose 
   */
  message WeightedRobotPose {
    required float probability = 1;
    required RobotEstimation robot = 2;
  }
  /**
   * Belief regarding positions of other robots in self referential
   * - First element represents the probability that the information is accurate
   * - Second element describes the robot
   */
  repeated WeightedRobotPose robots = 4;

  /**
   * Up to teams
   */
  required string freeField = 5;
}

enum Action {
  UNDEFINED        = 0;// None of the action matches current action
  POSITIONING      = 1;// Robot is repositionning (but do not plan to kick immediately)
  GOING_TO_KICK    = 2;// Robot is moving toward the ball in order to kick
  KICKING          = 3;// Robot is currently perforimg the kick motion
  GOING_TO_DRIBBLE = 4;// Robot is moving toward the ball and plans to dribble
  DRIBBLING        = 5;// Robot is actively dribbling
  WAITING          = 6;// Robot is waiting for something to happen  
}

/**
 * Describes the intention of the robot
 */
message IntentionMessage {
  /**
   * Destination of the robot in field referential
   */
  required PoseEstimation targetPoseInField = 1;

  /**
   * List of waypoints (when avoiding an obstacle for example), first element of
   * the vector is the next waypoint
   */
  repeated PoseEstimation waypointsInField = 2;

  /**
   * Current action planned by the robot
   */
  required Action actionPlanned = 3;

  /**
   * Estimated result for the ball position after next kick, when ball has
   * stopped
   */
  required PositionEstimation kickTargetInField = 4;

  /**
   * Up to teams
   */
  required string freeField = 5;
}

/**
 * Global task of the robot
 */
enum Role {
  UNSPECIFIED_ROLE = 0; // Unknown role
  GOALIE      = 1; // The robot is a goalie
  DEFENDER    = 2; // Robot is only defending its own goal
  OFFENDER    = 3; // Robot is actively trying to score goals
}

/**
 * Current status of the robot
 */
enum Status {
  UNSPECIFIED_STATUS = 0; // Unknown status
  OKAY             = 1; // Robot is playing without any disfunction
  FALLING          = 2; // Robot is currently falling
  FALLEN           = 3; // Robot is fallen on the ground and is not attempting to stand up
  STANDING_UP      = 4; // Robot is actively trying to stand up
  FREEZE           = 5; // Robot is freezing all motion in order to fulfill the rules
  HANDLED          = 6; // Robot is handled (carried by the handler)
  HARDWARE_FAILURE = 7; // Robot has a major hardware failure
}

/**
 * Should we include the possiblity of having a captain in the protocol?
 */
message TeamPlayMessage {
  required Role role = 1;

  required Status status = 2;
  
  /**
   * Up to teams
   */
  required string freeField = 3;
}

message CapabilitiesMessage {
  // Maximal walking speed of the robot [m/s]
  required float maxWalkingSpeed = 1;
  // Average kicking distance for robot kicks [m]
  required float avgKickDistance = 2;

  /**
   * Up to teams
   */
  required string freeField = 4;
}
